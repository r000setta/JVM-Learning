# 概述

## 1.运行时数据区域

### 程序计数器

### JVM栈

### 本地方法栈

### Java堆

基本用于存储对象。线程共享，垃圾收集器管理的主要区域，具体还可以细分(见垃圾回收算法该节)。Java堆可以处于物理不连续的内存空间中。如果堆中没有内存完成实例分配，并且堆无法在扩展时，会抛出OOM

### 方法区

线程共享，存储已被虚拟机加载的类信息，常量，静态变量，别名为Non-Heap。

### 运行时常量池

方法区的一部分，存放编译时期的各种字面量和符号引用。运行期间也可以将新的常量放入池中。

### 直接内存

并不是JVM运行时数据区的一部分，但是被频繁的使用。如NIO中，直接使用Native函数库分配堆外内存，然后通过堆中的DirectByteBuffer对象进行操作。该内存分配不受Java堆限制。

## 2.对象概述

### 对象创建过程

1. 遇到new指令，检查参数是否能在常量池中定位到一个类的符号引用。并检查这个符号引用代表的类是否已经被加载解析过
2. 为新生对象分配内存，对象所需的大小在类加载完成后便可完全确定。
3. 将分配到的内存空间初始化为零值，保证了对象的实例字段不赋初值就可以直接使用。
4. 设置对象头
5. new指令结束，执行\<init>方法，对象正式创建完成

### 对象内存布局

布局分三块区域：对象头，实例数据，对齐填充

#### 对象头：

1. Mark Word
2. 类型指针，对象指向它的类元数据的指针，用于判断这个对象是哪个类的实例。
3. 如果是数组，还有额外的一块用于记录数组的长度

#### 实例数据

存储真正有效的信息，即各种字段信息。记录存储顺序收到虚拟机分配策略参数影响。相同宽度的字段被分配到一起，父类变量出现在子类前。

#### 对齐填充

保证对象的大小是8字节的整数倍。

## 3.对象访问定位

 通过栈上的reference来操作堆上具体的对象，但栈上仅仅提供了一个引用。具体的定位取决于虚拟机的实现。

1. 句柄：额外划分一块内存区域作为句柄池
2. 指针访问

## 额外





